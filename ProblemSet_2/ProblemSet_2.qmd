---
title: "Problem Set 2"
author: "Behram Radmanesh"
format: 
  html:
      code-fold: true
      code-tools: true
toc: true
---

[Github Link](https://github.com/MediciPrime/STATS506/tree/main/ProblemSet_2)

## Problem 1 - Dice Game

This problem asks to create a function that codes for a dice game abiding by the following rules:
- The game uses a 6-sided dice and costs $2 to play per die rolled
- Winning roll requires a 3 or 5; anything else and you lose
- Winning value 3 produces 6 dollars; while value 5 produces 10 dollars

### Part A
#### Simple Loop

```{r}
## Function takes as input the number of dice rolls to play
loop <- function(num) {
  
  ## Check if input is numeric
  if (is.double(num) == TRUE) {
    
    ## If numeric then check if contains decimal
    if (num-as.integer(num) == 0) {
      
      ## Given it's not a decimal convert to integer
      num <- as.integer(num)
    }
    
    ## Given decimal check if a negative number was given
    else if (num-as.integer(num) < 0) {
      
      ## If negative decimal then tell user how number for converted
      cat("Negative entered value:", num, "was converted to", as.integer(-num), "\n")
      num <- as.integer(-num)
    }
    
    else {
      
      ## Given positive decimal convert accordingly
      cat("Entered value:", num, "converted to", as.integer(num), "\n")
      num <- as.integer(num)
    }
  }
  else if (is.numeric(num) == FALSE) {
    print("Please enter a natural number, eg. 1, 2, 3, ...")
    break
  }
  
  ## Create player deficit
  winnings = -(2*num)
  
  ## Simulate 'n'= num Dice Rolls
  rolls <- sample(1:6, num, replace=TRUE)
  
  ## Use for loop to calculate total winnings
  for (i in rolls) {
    
    ## if 3 is rolled add $6 to the winnings
    if (i == 3) {
      winnings <- winnings + 6
    }
    
    ## if 5 is rolled add $10 to the winnings
    else if (i == 5) {
      winnings <- winnings + 10
    }
  }
  return(cat("Total Winnings:", winnings))
}

```

#### Vetorized Function

```{r}
## Function takes as input the number of dice rolls to play
vectorized <- function(num) {
  
 ## Check if input is numeric
  if (is.double(num) == TRUE) {
    
    ## If numeric then check if contains decimal
    if (num-as.integer(num) == 0) {
      
      ## Given it's not a decimal convert to integer
      num <- as.integer(num)
    }
    
    ## Given decimal check if a negative number was given
    else if (num-as.integer(num) < 0) {
      
      ## If negative decimal then tell user how number for converted
      cat("Negative entered value:", num, "was converted to", as.integer(-num), "\n")
      num <- as.integer(-num)
    }
    
    else {
      
      ## Given positive decimal convert accordingly
      cat("Entered value:", num, "converted to", as.integer(num), "\n")
      num <- as.integer(num)
    }
  }
  else if (is.numeric(num) == FALSE) {
    print("Please enter a natural number, eg. 1, 2, 3, ...")
    break
  }
  
  ## Create player deficit
  deficit = -(2*num)
  
  ## Simulate 'n'= num Dice Rolls
  rolls <- sample(1:6, num, replace=TRUE)
  
  ## create a vector specifying winnings for each roll
  rollWinnings <- c(0, 0, 6, 0, 10, 0)
  
  ## using 'rolls' to index over the 'rollWinnings' vector
  ## sum over all the possible winnings
  winnings <- sum(rollWinnings[rolls])
  
  return(cat("Total Winnings:", winnings+deficit))
}

```

#### Vectorized with Tables

```{r}
## Function takes as input the number of dice rolls to play
tableVectorized <- function(num) {
  
  ## Check if input is numeric
  if (is.double(num) == TRUE) {
    
    ## If numeric then check if contains decimal
    if (num-as.integer(num) == 0) {
      
      ## Given it's not a decimal convert to integer
      num <- as.integer(num)
    }
    
    ## Given decimal check if a negative number was given
    else if (num-as.integer(num) < 0) {
      
      ## If negative decimal then tell user how number for converted
      cat("Negative entered value:", num, "was converted to", as.integer(-num), "\n")
      num <- as.integer(-num)
    }
    
    else {
      
      ## Given positive decimal convert accordingly
      cat("Entered value:", num, "converted to", as.integer(num), "\n")
      num <- as.integer(num)
    }
  }
  else if (is.numeric(num) == FALSE) {
    print("Please enter a natural number, eg. 1, 2, 3, ...")
    break
  }
  
  ## Create player deficit
  deficit = -(2*num)
  
  ## Simulate 'n'= num Dice Rolls & place the results into a table
  tRolls <- table(sample(1:6, num, replace=TRUE))
  
  ## create a vector specifying winnings for each roll
  rollWinnings <- c(0, 0, 6, 0, 10, 0)
  
  ## using 'tRolls' table to index over the 'rollWinnings' vector
  ## the table form avoids unnecessary looping over the rolls
  ## sum over all the possible winnings
  winnings <- sum(rollWinnings[as.numeric(names(tRolls))] * tRolls)
  
  return(cat("Total Winnings: ", winnings+deficit))
}

```

#### Loop with Apply

```{r}
## Function takes as input the number of dice rolls to play
loopApply <- function(num) {
  
  ## Check if input is numeric
  if (is.double(num) == TRUE) {
    
    ## If numeric then check if contains decimal
    if (num-as.integer(num) == 0) {
      
      ## Given it's not a decimal convert to integer
      num <- as.integer(num)
    }
    
    ## Given decimal check if a negative number was given
    else if (num-as.integer(num) < 0) {
      
      ## If negative decimal then tell user how number for converted
      cat("Negative entered value:", num, "was converted to", as.integer(-num), "\n")
      num <- as.integer(-num)
    }
    
    else {
      
      ## Given positive decimal convert accordingly
      cat("Entered value:", num, "converted to", as.integer(num), "\n")
      num <- as.integer(num)
    }
  }
  else if (is.numeric(num) == FALSE) {
    print("Please enter a natural number, eg. 1, 2, 3, ...")
    break
  }
  
  ## Create player deficit
  deficit = -(2*num)
  
  ## Simulate 'n'= num Dice Rolls
  rolls <- sample(1:6, num, replace=TRUE)
  
  ## create a vector specifying winnings for each roll
  rollWinnings <- c(0, 0, 6, 0, 10, 0)
  
  ## Using the apply function to sum up the winnings
  winnings <- apply(as.matrix(rollWinnings[rolls]), 2, sum)
  
  return(cat("Total Winnings: ", winnings+deficit))
}

```

### Part B

The following bit of code is here to demonstrate through examples that each of the functions work.

#### Simple Loop
```{r}
## Input of 3
loop(3)

## Input of 3000
loop(3000)

```

#### Vectorized Function
```{r}
## Input of 3
vectorized(3)

## Input of 3000
vectorized(3000)
```

#### Vectorized with Tables
```{r}
## Input of 3
tableVectorized(3)

## Input of 3000
tableVectorized(3000)
```

#### Loop with Apply
```{r}
## Input of 3
loopApply(3)

## Input of 3000
loopApply(3000)
```

### Part C

Set a seed in order to demonstrate that each of the 4 functions output the same results.

#### Simple Loop
```{r}
set.seed(10)

## Input of 3
loop(3)

## Input of 3000
loop(3000)

```

#### Vectorized Function
```{r}
set.seed(10)

## Input of 3
vectorized(3)

## Input of 3000
vectorized(3000)
```

#### Vectorized with Tables
```{r}
set.seed(10)

## Input of 3
tableVectorized(3)

## Input of 3000
tableVectorized(3000)
```

#### Loop with Apply
```{r}
set.seed(10)

## Input of 3
loopApply(3)

## Input of 3000
loopApply(3000)
```

### Part D

The 'microbenchmark' package will now be used to calculate the speed for each of the implementations.

#### Simple Loop
```{r}
library("microbenchmark")

## Input of 1000 vs 100,000
microbenchmark(loop(1000), loop(100000))

```

#### Vectorized Function
```{r}
## Input 1,000 vs 100,000
microbenchmark(vectorized(1000), vectorized(100000))
```

#### Vectorized with Tables
```{r}
## Input 1,000 vs 100,000
microbenchmark(tableVectorized(1000), tableVectorized(100000))
```

#### Loop with Apply
```{r}
## Input 1,000 vs 100,000
microbenchmark(loopApply(1000), loopApply(100000))
```

I was surprised to see that the Vectorized function which utilized a table was slower than all the other functions. I was under the assumption that using a table would have at least reduced the calculation time over the for loop used for the simple loop function, since we could use the table's index. Aside from that surprising result, loopApply was faster than the simple loop function but the fastest was the purely vectorized function. 

Thus in order of the fastest to the slowest: 

1. vectorized
2. loopApply
3. loop 'simple loop'
4. tableVectorized

### Part E
#### Monte Carlo Simulation
The idea of a game being fair in my opinion relies upon an equal chance for the player to make money vs lose money. For example, in a game of tossing a coin and calling a side, the player would have an equal chance of both winning and losing.  

```{r}
## Monte Carlo simulation
monte <- function(reps, rolls=1) {
  v <- vector(length = reps)
  for (i in seq_len(reps)) {
    v[i] <- vectorized(rolls)
  }
  hist(v)
  return(table(v)/reps)
}
```

##### Various Simulations
```{r}
## Reps=1,000,000 & Rolls=1
monte(100000)

## Reps=1,000,000 & Rolls=6
monte(reps=100000, rolls=6)

## Reps=1,000,000 & Rolls=100
monte(reps = 100000, rolls=100)

```